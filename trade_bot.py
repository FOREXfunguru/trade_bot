import logging
import pdb
import datetime
import pandas as pd
import os

from oanda.connect import Connect
from config import CONFIG
from tradebot_utils import *
from utils import *
from candle.candle import *

# create logger
tb_logger = logging.getLogger(__name__)
tb_logger.setLevel(logging.DEBUG)

class TradeBot(object):
    '''
    This class represents an automatic Trading bot

    Class variables
    ---------------
    start: datetime, Required
           Datetime that this Bot will start operating. i.e. 20-03-2017 08:20:00s
    end: datetime, Required
         Datetime that this Bot will end operating. i.e. 20-03-2020 08:20:00s
    pair: str, Required
          Currency pair used in the trade. i.e. AUD_USD
    timeframe: str, Required
               Timeframe used for the trade. Possible values are: D,H12,H10,H8,H4
    '''
    def __init__(self, start, end, pair, timeframe):
        self.start = start
        self.end = end
        self.pair = pair
        self.timeframe = timeframe

    def __get_trade_type(self, ic, delta):
        '''
        Function to guess what is the trade type (short or long)
        for this possible trade. It will also adjust the SL price
        to the most recent highest high/lowest low

        Parameters
        ----------
        ic : Candle object
             Indecision candle for this trade
        delta : Timedelta object corresponding to
                the time that needs to be increased

        Returns
        -------
        str: Trade type (long or short)
        float: adjusted SL
        '''

        conn = Connect(instrument=self.pair,
                       granularity=self.timeframe)

        # n x delta controls how many candles to go back in time
        # to check
        start = ic.time-20*delta
        end = ic.time

        tb_logger.info("Fetching data from API")
        res = conn.query(start=start.isoformat(),
                         end=end.isoformat())

        clObj = CandleList(res, id='fit_reg')
        # fit a regression line in order to check its slope
        # and guess the trade type
        (fitted_model, regression_model_mse) = clObj.fit_reg_line()

        slope = fitted_model.coef_[0][0]

        if slope < 0:
            type = 'long'
        elif slope > 0:
            type = 'short'

        # adjust SL
        if type == 'short':
            part = 'high{0}'.format(CONFIG.get('general', 'bit'))
        elif type == 'long':
            part = 'low{0}'.format(CONFIG.get('general', 'bit'))

        SL = None
        for c in reversed(candle_list):
            price = getattr(c, part)
            if SL is None:
                SL = price
                continue
            if type == 'short':
                if price > SL:
                    SL = price
            if type == 'long':
                if price < SL:
                    SL = price

        return type, SL

    def prepare_trade(self, type, SL, ic, harea_sel, delta):
        '''
        Prepare a Trade object
        and check if it is taken

        Parameters
        ----------
        type : str,
               Type of trade. 'short' or 'long'
        SL : float,
             Adjusted (by '__get_trade_type') SL price
        ic : Candle object
             Indecision candle for this trade
        harea_sel : HArea of this trade
        delta : Timedelta object corresponding to
                the time that needs to be increased

        Returns
        -------
        Trade object
        '''
        startO = ic.time + delta
        if type == 'short':
            # entry price will be the low of IC
            entry_p = getattr(ic, "low{0}".format(self.settings.get('general', 'bit')))
        elif type == 'long':
            # entry price will be the high of IC
            entry_p = getattr(ic, "high{0}".format(self.settings.get('general', 'bit')))
        startO = ic.time+delta
        t = Trade(
            id='{0}.bot'.format(self.pair),
            start=startO.strftime('%Y-%m-%d %H:%M:%S'),
            pair=self.pair,
            timeframe=self.timeframe,
            type=type,
            entry=entry_p,
            SR=harea_sel.price,
            SL=SL,
            RR=self.settings.getfloat('trade_bot', 'RR'),
            strat='counter')

        return t

    def run(self, discard_sat=True, pickled_file=None):
        '''
        This function will run the Bot from start to end
        one candle at a time

        Parameter
        ---------
        discard_sat : Bool
                      If this is set to True, then the Trade wil not
                      be taken if IC falls on a Saturday. Default: True
        pickled_file : str
                       Path used to dump the pickled representation of the dict
                       of HAreaList generated by store_SRlist (if self.settings.
                       getboolean('trade_bot', 'store_SRlist' is True
                       Or path used to load the pickled representation (if
                       self.settings.getboolean('trade_bot', 'load_SRlist' is
                       True)

        Returns
        -------
        TradeList object with Trades taken. None if no trades
        were taken
        '''
        tb_logger.info("Running...")

        conn = Connect(instrument=self.pair,
                       granularity=self.timeframe)

        delta = nhours = None
        if self.timeframe == "D":
            nhours = 24
            delta = timedelta(hours=24)
        else:
            p1 = re.compile('^H')
            m1 = p1.match(self.timeframe)
            if m1:
                nhours = int(self.timeframe.replace('H', ''))
                delta = datetime.timedelta(hours=int(nhours))

        # convert to datetime the start and end for this TradeBot
        startO = pd.datetime.strptime(self.start, '%Y-%m-%d %H:%M:%S')
        endO = pd.datetime.strptime(self.end, '%Y-%m-%d %H:%M:%S')

        dict_SRlist = {}
        if CONFIG.getboolean('trade_bot', 'load_SRlist') is True:
            tb_logger.info("Loading dict of HAreaLists from pickled "
                           "file: {0}".format(pickled_file))
            pickled_fh = open(pickled_file, 'rb')
            dict_SRlist = pickle.load(pickled_fh)

        loop = 0
        tlist = []
        tend = SRlst = None
        # calculate the start datetime for the CList that will be used
        # for calculating the S/R areas
        delta_period = periodToDelta(CONFIG.getint('counter', 'period'),
                                     self.timeframe)
        initc_date = startO-delta_period

        while startO <= endO:
            if tend is not None:
                # this means that there is currently an active trade
                if startO <= tend:
                    startO = startO + delta
                    loop += 1
                    continue
                else:
                    tend = None
            tb_logger.info("Trade bot - analyzing candle: {0}".format(startO.isoformat()))
            if loop == 0:
                # no iteration has occurred yet, so invoke .calc_SR for the first time
                if CONFIG.getboolean('trade_bot', 'load_SRlist') is True:
                    SRlst= dict_SRlist[startO]
                else:
                    SRlst = calc_SR(self,
                                    start=initc_date,
                                    end=startO)
                res = SRlst.print()
                dict_SRlist[startO] = SRlst
                tb_logger.info("Identified HAreaList for time {0}:".format(startO.isoformat()))
                tb_logger.info("{0}".format(res))
            elif loop >= CONFIG.getint('trade_bot',
                                       'period'):
                # An entire cycle has occurred. Invoke .calc_SR
                if CONFIG.getboolean('trade_bot', 'load_SRlist') is True:
                    SRlst = dict_SRlist[startO]
                else:
                    SRlst = self.calc_SR(start=initc_date,
                                         end=startO)
                res = SRlst.print()
                dict_SRlist[startO] = SRlst
                tb_logger.info("Identified HAreaList for time {0}:".format(startO.isoformat()))
                tb_logger.info("{0}".format(res))
                loop = 0
            pdb.set_trace()
            # fetch candle for current datetime
            tb_logger.info("Fetching data from API")
            res = conn.query(start=startO.isoformat(),
                             count=1)

            # this is the current candle that
            # is being checked
            c_candle = Candle(dict_data=res['candles'][0])
            c_candle.time = datetime.strptime(c_candle.time,
                                              '%Y-%m-%dT%H:%M:%S.%fZ')

            # c_candle.time is not equal to startO
            # when startO is non-working day, for example
            delta1hr = timedelta(hours=1)
            if (c_candle.time != startO) and (abs(c_candle.time-startO) > delta1hr):
                loop += 1
                tb_logger.info("Analysed dt {0} is not the same than APIs returned dt {1}."
                               " Skipping...".format(startO, c_candle.time))
                startO = startO + delta
                continue

            #check if there is any HArea overlapping with c_candle
            HAreaSel, sel_ix = SRlst.onArea(candle=c_candle)

            if HAreaSel is not None:
                c_candle.set_candle_features()
                # guess the if trade is 'long' or 'short'
                type, SL = self.__get_trade_type(ic=c_candle, delta=delta)
                prepare_trade = False
                if c_candle.indecision_c(ic_perc=CONFIG.getint('general', 'ic_perc')) is True:
                    prepare_trade = True
                elif type == 'short' and c_candle.colour == 'red':
                    prepare_trade = True
                elif type == 'long' and c_candle.colour == 'green':
                    prepare_trade = True

                # discard if IC falls on a Saturday
                if c_candle.time.weekday() == 5 and discard_sat is True:
                    tb_logger.info("Possible trade at {0} falls on Sat. Skipping...".format(c_candle.time))
                    prepare_trade = False

                if prepare_trade is True:
                    t = self.prepare_trade(
                        type=type,
                        SL=SL,
                        ic=c_candle,
                        harea_sel=HAreaSel,
                        delta=delta)
                    t.strat = 'counter'
                    t.tot_SR = len(SRlst.halist)
                    t.rank_selSR = sel_ix
                    # calculate t.entry-t.SL in number of pips
                    # and discard if it is over threshold
                    diff = abs(t.entry-t.SL)
                    number_pips = float(calculate_pips(self.pair, diff))
                    if number_pips > CONFIG.getint('trade_bot', 'SL_width_pips'):
                        loop += 1
                        startO = startO + delta
                        continue
                    if CONFIG.getboolean('trade_bot', 'run_trades') is True:
                        t.run_trade(expires=2)
                        if t.entered is True:
                            if not hasattr(t, 'end'):
                                tb_logger.info("Trade.end will be n.a. Check if this trade hit the SL/TP in"
                                               "the analysed timeframe. Skipping...")
                                tend = None
                            else:
                                tlist.append(t)
                                tend = t.end
                    else:
                        tlist.append(t)
            startO = startO+delta
            loop += 1

        tb_logger.info("Run done")

        if self.settings.getboolean('trade_bot', 'store_SRlist') is True:
            tb_logger.info("Dumping dict of HAreaLists to pickled "
                           "file: {0}".format(pickled_file))
            pickled_lst_f = open(pickled_file, 'wb')
            pickle.dump(dict_SRlist, pickled_lst_f)
            pickled_lst_f.close()

        if len(tlist) == 0:
            return None
        else:
            tl = TradeList(tlist=tlist)

            if CONFIG.getboolean('trade_bot', 'run_trades') is True:
                # analyse trades
                tl.analyze()
            return tl